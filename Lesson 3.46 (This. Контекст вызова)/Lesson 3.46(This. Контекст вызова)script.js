'use strict';
//  по простому this это, то что окружает функцию и в каких условиях она вызывается
// Пример для представления контекста вызова. Представим, что у нас есть бомж, получается, что он функционирует в пределах всего мира, у него нет какой-то конкретной привязки к конкретному месту, но если мы ему дадим жильё, то он получит контекст вызова.
// функция может вызываться 4мя способами, и в каждом контекст вызова отличается. 

// 1) просто вызов функции
function showThis() {
	console.log(this);
}

showThis();
// без строго режима ('use strict';) мы получим window - т.е. ссылается на глобальный объект, если строгий режим, то получим undefined

// ---------------------
// практическая задачка, часто дают на собесах
function showThis2(a, b) {
	console.log(this);
	function sum() {
		console.log(this);
		// return this.a + this.b; // но это не сработает
		return a + b; // да в функции sum таких аргументов нет, но тут используется замыкание, и функция пойдёт выше искать a и b и найдёт в функции showThis2 их.
	}

	console.log(sum());
}

showThis2(4, 5);
// ---------------------

// 2) Контекст у методов объектов - это сам объект
const obj = {
	a: 20,
	b: 15,
	sum2: function () {
		console.log(this);
	}
};

obj.sum2(); // мы получим объект, в котором находится этот метод

// Немного поэксперементируем
const obj = {
	a: 20,
	b: 15,
	sum2: function () {
		function shout() {// допустим внутри этого метода есть функция
			console.log(this);
		}
		shout();
	}
};

obj.sum2(); // то у нас будет undefined. ПОЧЕМУ? Потому что это простой вызов функции, он уже не относится к методу, это не метод объекта, это функция, которая запускается внутри метода, поэтому контекст вызова она взяла и потеряла



// 3)
function User(name, id) {
	this.name = name;
	this.id = id;
	this.human = true;
}
let Ivan = new User('Ivan', 23);


// 4) 
function sayName(surname) {
	console.log(this);
	console.log(this.name + surname);
}

const user = {
	name: 'John'
};

// два варианта присвоения ручаного контекста
// разница у колл и эплай, лишь в синтаксисах, то, что аргумент у одного передаётся просто, у второго в массиве. 
sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);

// третий вариант присвоения ручаного контекста, с помощью метода bind
function count(num) {
	return this*num;
}

const double = count.bind(2); // его существенное отличие от метода call и apply в том, что он создаёт новую функцию. т.е. теперь double это функция, в которую мы будем передавать число, которое будет удваеваться
console.log(double(3));






// Коротко:
// 1) Обычная функция: this = window, но если use strict - undefined
// 2) Контекст у методов объектов - это сам объект
// 3) this в конструкторах и классах - это новый экземпляр объекта
// 4) Ручная привязка this с помощью методов call, apply, bind