const btn = document.querySelector('button');

btn.addEventListener('click', function () {
	console.log(this); // если мы вызываем в классическом варианте функцию, то контекст вызова будет сам элемент по которому мы кликаем. т.е. this тут будет как event.target(в практике чаще используется именно объект события event.target)
	this.style.backgroundColor = 'red';
});

// поговорим о том, что если мы используем стрелочную функцию, то вспомним, что стрелочная не имеет своего конткеста вызова, она будет его всегда брать у своего родителя

const obj = {
	num: 5,
	sayNumber: function () {
		const say = () => {
			console.log(this); // если бы тут взяли обычную функцию, то у нас бы было undefined, но т.к. у стрелочной нет своего контекста, она берёт контекст у родителя sayNumber, а метод ссылается на объект
		};

		say();
	}
}

obj.sayNumber();

// если в примере где по нажатию мы меняем цвет кнопки заменить функцию на стрелочную функцияю, она работать не будет. У стрелочной функции своего контекста нет.
// отсюда правило!!! 
// в обработчике событий при использовании стрелочной функции не может быть использован this(но спокойно может и чаще используется - e.target)



// -----------------------
// для чего стрелочная функция ещё создана? для сокращения кода

// const double = (a) => {
// 	return a * 2;
// }; // это хорошо, правильно, но в стрелочной функции мы можем запистаь короче, если тело функции содержит одну строку
// const double = (a) => a * 2; // return подставляется автоматом. но можно ещё сократить, если стрелочная функция содержит только 1 аргумент, убрав скобки у аргумента

const double = a => a * 2;

console.log(double(4));