'use strict';
//  по простому this это, то что окружает функцию и в каких условиях она вызывается
// Пример для представления контекста вызова. Представим, что у нас есть бомж, получается, что он функционирует в пределах всего мира, у него нет какой-то конкретной привязки к конкретному месту, но если мы ему дадим жильё, то он получит контекст вызова.
// функция может вызываться 4мя способами, и в каждом контекст вызова отличается. 

// 1) просто вызов функции
function showThis() {
	console.log(this);
}

showThis();
// без строго режима ('use strict';) мы получим window - т.е. ссылается на глобальный объект, если строгий режим, то получим undefined

// ---------------------
// практическая задачка, часто дают на собесах
function showThis2(a, b) {
	console.log(this);
	function sum() {
		console.log(this);
		// return this.a + this.b; // но это не сработает
		return a + b; // да в функции sum таких аргументов нет, но тут используется замыкание, и функция пойдёт выше искать a и b и найдёт в функции showThis2 их.
	}

	console.log(sum());
}

showThis2(4, 5);
// ---------------------

// 2) Контекст у методов объектов - это сам объект
const obj = {
	a: 20,
	b: 15,
	sum2: function () {
		console.log(this);
	}
};

obj.sum2(); // мы получим объект, в котором находится этот метод

// Немного поэксперементируем
const obj = {
	a: 20,
	b: 15,
	sum2: function () {
		function shout() {// допустим внутри этого метода есть функция
			console.log(this);
		}
		shout();
	}
};

obj.sum2(); // то у нас будет undefined. ПОЧЕМУ? Потому что это простой вызов функции, он уже не относится к методу, это не метод объекта, это функция, которая запускается внутри метода, поэтому контекст вызова она взяла и потеряла



// 3)
function User(name, id) {
	this.name = name;
	this.id = id;
	this.human = true;
}
let Ivan = new User('Ivan', 23);


// 4) 
function sayName(surname) {
	console.log(this);
	console.log(this.name + surname);
}

const user = {
	name: 'John'
};

// два варианта присвоения ручаного контекста
// разница у колл и эплай, лишь в синтаксисах, то, что аргумент у одного передаётся просто, у второго в массиве. 
sayName.call(user, 'Smith');
sayName.apply(user, ['Smith']);

// третий вариант присвоения ручаного контекста, с помощью метода bind
function count(num) {
	return this*num;
}

const double = count.bind(2); // его существенное отличие от метода call и apply в том, что он создаёт новую функцию. т.е. теперь double это функция, в которую мы будем передавать число, которое будет удваеваться
console.log(double(3));






// Коротко:
// 1) Обычная функция: this = window, но если use strict - undefined
// 2) Контекст у методов объектов - это сам объект
// 3) this в конструкторах и классах - это новый экземпляр объекта
// 4) Ручная привязка this с помощью методов call, apply, bind



// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------
// подробнее про call, apply, bind

function hello() {
	console.log('Hi', this);
}

const person = {
	name: 'Ben',
	age 35,
	sayHelloDoc: hello.bind(document), // bind может менять контекст.
	logInfo: function (job, phone) {
		console.log(`Name is ${this.name}`);
		console.log(`Age is ${this.age}`);
		console.log(`Job is ${job}`);
		console.log(`Phone is ${phone}`);
	}
}

const lena = {
	name: 'Elena',
	age: 28
}

// можем ли вызвать функцию logInfo у Лены, казалось бюы функции нет у Лены такой. Да, но она есть у другого объекта и поменяв контекст мы можем это сделать. Чтобы его поменять нужен bind
person.logInfo.bind(lena)();
// также можем передать параметры job и phone
person.logInfo.bind(lena)('manager', '8-8213-123-123');
// но bind хорош тем, что он может в себя принять эти аргументы
person.logInfo.bind(lena, 'manager', '8-8213-123-123')();
// метод call - отличается тем, что его не нужно вызывать
person.logInfo.call(lena, 'manager', '8-8213-123-123');
// метод apply - отличается от call тем, что мы можем передавать только два аргумента. один из которых массив. Это массив из аргументов, которые попадут в функцию
person.logInfo.apply(lena, ['manager', '8-8213-123-123']);

// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------
// -----------------------------------------------------------

const arr = [1, 2, 3, 4, 5];

function multBy(arr, n) {
	return arr.map(item => item * n);
}

console.log(multBy(arr, 10));

// но как нам сделать, чтобы у всех массивах была такая функция. См ниже

Array.prototype.multBy = function multBy(n) {
	return this.map(item => item * n);
}

// и теперь у нас у всех! массивов есть такая функция! круто!

array.multBy(2);