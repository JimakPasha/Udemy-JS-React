'use strict';

// функция по классификации является объектом и по идее в неё можно записать методы и свойства.


// старый синтаксис создания функций-конструкторов
const num = new Number(3); // создаём как бы новое число
console.log(num);

const num2 = new Function(3); // и если такая функция будет содеражать методы и свойства, то она в итоге создаст нам новый объект
console.log(num2);


// новый синтаксис создания функций - конструкторов
function User(name, id) {
	this.name = name;
	this.id = id;
	this.human = true;
	this.hello = function() { // так можем создать метод
		console.log(`Hello, ${this.name}!`);
	}
}

User.prototype.exit = function() {
	console.log(`User ${this.name} exit`); 
} // тем самым мы добавили новый метод для нашего объекта. и этот метод будет наследорваться у васех потомков нашего прототипа

const ivan = new User('Ivan', 28); // тут мы создали новый объект
const alex = new User ('Alex', 20);

console.log(ivan);
console.log(alex);

ivan.hello();
alex.hello();

ivan.exit();

// !!ПОДЫТОЖИМ!!! Конструкторы нам нужны для создания новых однотипных объектов. В практике это могут быть новые юзеры сайта, товары в магазине, ролики на ютубе, везде где есть шаблонизация. Даже компоненты сайтов могут так создаваться (например у нас на сайте есть слайдеры, они почти одинаковые, но отличаются кол-вом слайдов...). Т.е. один раз настраиваем большой прототип, а потом уже настраиваем при вызове нового конструктора

// ВАЖНО! Мы сейчас разобрали стандарт es5 - это то, как всё происходит под капотом js, его внутренности. В стандарте es6 - у нас появилась такая вещь как классы - синтаксический сахар, т.е. красивая обёртка вот этого всего функционала, который существует внутри. Классы действительно удобнее использовать, поэтому реальный функционал обычно создаётся с использованием классов. Т.е. в этом уроке мы разобрали как происходит всё внутри.

// В JS изначально классов не было они появились в качестве синтаксического сахара. В др языках программирования это немножко не так.