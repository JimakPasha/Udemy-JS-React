const btn = document.querySelector('.btn');
const elem = document.querySelector('.box');

function myAnimation() {
  let position = 0;

  const id = setInterval(frame, 10);
  function frame() {
    if (position == 300) {
      clearInterval(id);
    } else {
      position ++;
      elem.style.top = position + 'px';
      elem.style.left = position + 'px';
    }
  }
}

btn.addEventListener('click', myAnimation);

// этот способ нормально бы работал, но если разбираться в тех деталях монитора и пк, то скорость обновления кадров в мониторе и браузере будет разная.
// большинтво мониторов стараются показать 60 кадров в сек. Браузер постоянно перерисовывает контент, кот. находится на странице. Она примерно 60 кадров в сек, но это зависит от нагрузки на пк. Частота перерисовки не постоянная, и стремится всегда к какому-то значению. И вот тут если мы задаём свою анимацию, то мы задаём частоту кадров ->   const id = setInterval(frame, 10); тут 10 млсек. И это рассинхронизация, т.е. наш сетинтервал застовляет перерисовывать не в тоже время как наш пк, и это ведёт к нагрузке на пк. Если мы будем запускать много таких анимаций, то пк загрузится ещё больше.
// чтобы это всё решить создали функцию RequestAnimationFrame




// RequestAnimationFrame - позволяет запускать функции в качестве анимации. Функция подстраивает внутренние функции под частоту обновления кадров вашего браузера.
// продолжение смотреть в папке practice-2. там мы функционал оставим, но код значитеьно улучшим с помощью RequestAnimationFrame